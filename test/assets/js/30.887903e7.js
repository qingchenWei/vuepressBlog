(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{513:function(t,e,s){"use strict";s.r(e);var a=s(4),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("Abstract")]),t._v(" "),s("ol",[s("li",[t._v("Vue3 中，抛弃了defineProperty而使用Proxy来实现数据监听，本文讲述它们两者的区别")])])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.infoq.cn/article/sPCMAcrdAZQfmLbGJeGr",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考网址"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"object-defineproperty-vs-proxy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty-vs-proxy"}},[t._v("#")]),t._v(" "),s("code",[t._v("Object.defineProperty")]),t._v(" VS Proxy")]),t._v(" "),s("p",[s("strong",[t._v("1. "),s("code",[t._v("Object.defineProperty")]),t._v("只能劫持对象的属性，而 Proxy 是直接代理对象。")])]),t._v(" "),s("p",[t._v("由于 "),s("code",[t._v("Object.defineProperty")]),t._v(" 只能对属性进行劫持，需要遍历对象的每个属性，如果属性值也是对象，则需要深度遍历。而 Proxy 直接代理对象，不需要遍历操作。")]),t._v(" "),s("p",[s("strong",[t._v("2. "),s("code",[t._v("Object.defineProperty")]),t._v("对新增属性需要手动进行 Observe。")])]),t._v(" "),s("p",[t._v("由于 "),s("code",[t._v("Object.defineProperty")]),t._v("劫持的是对象的属性，所以新增属性时，需要重新遍历对象，对其新增属性再使用 "),s("code",[t._v("Object.defineProperty")]),t._v(" 进行劫持。")]),t._v(" "),s("p",[t._v("也正是因为这个原因，使用 Vue 给 data 中的数组或对象新增属性时，需要使用 vm.$set 才能保证新增的属性也是响应式的。")]),t._v(" "),s("p",[t._v("下面看一下 Vue 的 set 方法是如何实现的，set 方法定义在 core/observer/index.js ，下面是核心代码。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("target"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Array"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果 target 是数组，且 key 是有效的数组索引，会调用数组的 splice 方法，")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 我们上面说过，数组的 splice 方法会被重写，重写的方法中会手动 Observe")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所以 vue 的 set 方法，对于数组，就是直接调用重写 splice 方法")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isArray")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isValidArrayIndex")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Math"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("splice")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" val\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对于对象，如果 key 本来就是对象中的属性，直接修改值就可以触发更新")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" target "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" val\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// vue 的响应式对象中都会添加了 __ob__ 属性，所以可以根据是否有 __ob__ 属性判断是否为响应式对象")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ob "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__ob__\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果不是响应式对象，直接赋值")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("ob"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    target"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" val\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用 defineReactive 给数据添加了 getter 和 setter，")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所以 vue 的 set 方法，对于响应式的对象，就会调用 defineReactive 重新定义响应式对象，defineReactive 函数")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineReactive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ob"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  ob"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dep"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("notify")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" val\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br"),s("span",{staticClass:"line-number"},[t._v("24")]),s("br"),s("span",{staticClass:"line-number"},[t._v("25")]),s("br"),s("span",{staticClass:"line-number"},[t._v("26")]),s("br"),s("span",{staticClass:"line-number"},[t._v("27")]),s("br"),s("span",{staticClass:"line-number"},[t._v("28")]),s("br"),s("span",{staticClass:"line-number"},[t._v("29")]),s("br"),s("span",{staticClass:"line-number"},[t._v("30")]),s("br"),s("span",{staticClass:"line-number"},[t._v("31")]),s("br"),s("span",{staticClass:"line-number"},[t._v("32")]),s("br")])]),s("p",[t._v("在 set 方法中，对 target 是数组和对象做了分别的处理，target 是数组时，会调用重写过的 splice 方法进行手动 Observe 。")]),t._v(" "),s("p",[t._v("对于对象，如果 "),s("code",[t._v("key")]),t._v(" 本来就是对象的属性，则直接修改值触发更新，否则调用 defineReactive 方法重新定义响应式对象。")]),t._v(" "),s("p",[t._v("如果采用 "),s("code",[t._v("proxy")]),t._v(" 实现，"),s("code",[t._v("Proxy")]),t._v(" 通过 "),s("code",[t._v("set(target, propKey, value, receiver)")]),t._v(" 拦截对象属性的设置，是可以拦截到对象的新增属性的。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.infoq.cn/resource/image/e2/a4/e2343cd3f9db6420d3ec97af35a3eba4.png",alt:"为什么Vue3.0不再使用defineProperty实现数据监听？"}})]),t._v(" "),s("p",[t._v("不止如此，Proxy 对数组的方法也可以监测到，不需要像上面 Vue2.x 源码中那样进行 hack。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.infoq.cn/resource/image/e8/5e/e8ef44354b7ccb0bd06d0160a00de15e.png",alt:"为什么Vue3.0不再使用defineProperty实现数据监听？"}})]),t._v(" "),s("p",[t._v("完美！！！")]),t._v(" "),s("p",[s("strong",[t._v("3. "),s("code",[t._v("Proxy")]),t._v("支持 13 种拦截操作，这是"),s("code",[t._v("defineProperty")]),t._v("所不具有的。")])]),t._v(" "),s("ul",[s("li",[s("strong",[s("code",[t._v("get(target, propKey, receiver)")])]),t._v("：拦截对象属性的读取，比如 "),s("code",[t._v("proxy.foo")]),t._v(" 和"),s("code",[t._v("proxy['foo']")]),t._v("。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("set(target, propKey, value, receiver)")])]),t._v("：拦截对象属性的设置，比如"),s("code",[t._v("proxy.foo = v")]),t._v(" 或 "),s("code",[t._v("proxy['foo'] = v")]),t._v("，返回一个布尔值。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("has(target, propKey)")])]),t._v("：拦截 "),s("code",[t._v("propKey in proxy")]),t._v(" 的操作，返回一个布尔值。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("deleteProperty(target, propKey)")])]),t._v("：拦截 "),s("code",[t._v("delete proxy[propKey]")]),t._v(" 的操作，返回一个布尔值。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("ownKeys(target)")])]),t._v("：拦截"),s("code",[t._v("Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in")]),t._v("循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 "),s("code",[t._v("Object.keys()")]),t._v(" 的返回结果仅包括目标对象自身的可遍历属性。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("getOwnPropertyDescriptor(target, propKey)")])]),t._v("：拦截"),s("code",[t._v("Object.getOwnPropertyDescriptor(proxy, propKey)")]),t._v("，返回属性的描述对象。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("defineProperty(target, propKey, propDesc)")])]),t._v("：拦截"),s("code",[t._v("Object.defineProperty(proxy, propKey, propDesc）")]),t._v("、"),s("code",[t._v("Object.defineProperties(proxy, propDescs)")]),t._v("，返回一个布尔值。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("preventExtensions(target)")])]),t._v("：拦截 "),s("code",[t._v("Object.preventExtensions(proxy)")]),t._v("，返回一个布尔值。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("getPrototypeOf(target)")])]),t._v("：拦截 "),s("code",[t._v("Object.getPrototypeOf(proxy)")]),t._v("，返回一个对象。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("isExtensible(target)")])]),t._v("：拦截 "),s("code",[t._v("Object.isExtensible(proxy)")]),t._v("，返回一个布尔值。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("setPrototypeOf(target, proto)")])]),t._v("：拦截 "),s("code",[t._v("Object.setPrototypeOf(proxy, proto)")]),t._v("，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("apply(target, object, args)")])]),t._v("：拦截 "),s("code",[t._v("Proxy")]),t._v(" 实例作为函数调用的操作，比如"),s("code",[t._v("proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)")]),t._v("。")]),t._v(" "),s("li",[s("strong",[s("code",[t._v("construct(target, args)")])]),t._v("：拦截 "),s("code",[t._v("Proxy")]),t._v(" 实例作为构造函数调用的操作，比如"),s("code",[t._v("new proxy(...args)")]),t._v("。")])]),t._v(" "),s("p",[s("strong",[t._v("4. 新标准性能红利")])]),t._v(" "),s("p",[s("code",[t._v("Proxy")]),t._v(" 作为新标准，从长远来看，JS 引擎会继续优化 "),s("code",[t._v("Proxy")]),t._v("，但 "),s("code",[t._v("getter")]),t._v(" 和 "),s("code",[t._v("setter")]),t._v(" 基本不会再有针对性优化。")]),t._v(" "),s("p",[s("strong",[t._v("5. "),s("code",[t._v("Proxy")]),t._v(" 兼容性差")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.infoq.cn/resource/image/45/bb/4548f6bc1d02622fa91450f6335663bb.png",alt:"为什么Vue3.0不再使用defineProperty实现数据监听？"}})]),t._v(" "),s("p",[t._v("可以看到，"),s("code",[t._v("Proxy")]),t._v(" 对于 IE 浏览器来说简直是灾难。")]),t._v(" "),s("p",[t._v("并且目前并没有一个完整支持 Proxy 所有拦截方法的 Polyfill 方案，有一个 google 编写的 "),s("a",{attrs:{href:"https://github.com/GoogleChrome/proxy-polyfill",target:"_blank",rel:"noopener noreferrer"}},[t._v("proxy-polyfill "),s("OutboundLink")],1),t._v("也只支持了 get、set、apply、construct 四种拦截，可以支持到 IE9+ 和 Safari 6+。")]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("Object.defineProperty")]),t._v(" 并非不能监控数组下标的变化，Vue2.x 中无法通过数组索引来实现响应式数据的自动更新是 Vue 本身的设计导致的，不是 defineProperty 的锅。")]),t._v(" "),s("li",[s("code",[t._v("Object.defineProperty")]),t._v(" 和 "),s("code",[t._v("Proxy")]),t._v(" 本质差别是，"),s("code",[t._v("defineProperty")]),t._v(" 只能对属性进行劫持，所以出现了需要递归遍历，新增属性需要手动 "),s("code",[t._v("Observe")]),t._v(" 的问题。")]),t._v(" "),s("li",[s("code",[t._v("Proxy")]),t._v(" 作为新标准，浏览器厂商势必会对其进行持续优化，但它的兼容性也是块硬伤，并且目前还没有完整的 polyfill 方案。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);